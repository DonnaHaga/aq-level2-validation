---
title: "Import Data"
output: html_notebook
params:
  stations: "stations_omineca.csv"
  preppedData: "omineca.rds"
---

Must have local mirrored copy of ftp site in .feather format. (www.github.com/DonnaHaga/dataImport)

```{r setup}
library(tidyverse)
# source from github:
#https://github.com/opetchey/RREEBES/wiki/Reading-data-and-code-from-an-online-github-repository

# source importFeatherFcn from github:
devtools::source_url("https://raw.githubusercontent.com/DonnaHaga/dataImport/master/functions/importFeatherFcn.R")

```

Specify the paths to the local FTP duplicate (.feather); type of data (time period and unverified or verified) is also specified here.

```{r pathsToData}
# Path to feather data
#workstn
# airFTP<-"C:/airFTPdata"
#mac
airFTP<-"/Volumes/DataScience/airFTPdata"

# path to unverified data
(dataPath<-file.path(airFTP,
                    "Hourly_Raw_Air_Data/Year_to_Date"))
```

```{r declareParameters}

# FILTER FOR YEAR TO VALIDATE:
yearToValidate<-2019

# Import feather data for all parameters and combine into one tibble,
# filter for yearToValidate

# list all files in dataPath:
dir(dataPath)

parameters<-c("CO",
              "H2S",
              "HUMIDITY",
              "NO",
              "NO2",
              "NOX",
              "O3",
              "PM10",
              "PM25",
              "SO2",
              "TEMP_MEAN",
              "TRS",
              "WDIR_VECT",
              "WSPD_SCLR")

# generate allStations = character vector of all stations:
(allStations<-feather::read_feather(file.path(dataPath,
                                             "bc_air_monitoring_stations.feather")) %>%
  pull(STATION_NAME)) %>% unique
```

```{r importData}
# call the importFeatherFcn to import data into R.
data<-purrr::map_dfr(parameters,
                     function(x){
                       
                       paste("Importing",x,"data...")
                       
                       importFeatherFcn(feather=dataPath,
                                        parameter = x,
                                        # I'm not sure why I had this here instead of just x
                                        # parameter = stringr::str_replace(x,
                                        #                                  ".feather",
                                        #                                  ""),
                                        station=allStations,
                                        year=yearToValidate)$stationData
                     })  %>%# map_dfr
  # filter for yearToValidate:
  dplyr::filter(format(DATE_PST,"%Y") %in% yearToValidate)
```

Pad time series with NA's to complete the annual time series. Note this includes down to the STATION_NAME_FULL looping level. (updated in Mar 2020). Looping through STATION_NAME isn't sufficient because it can lead to duplicates (between, for example, Birchbank_Golf_Course and Birchbank_Golf_Course_60).



```{r allStations}
(allStations<-data %>%
          dplyr::pull(STATION_NAME_FULL) %>%
          unique %>%
          sort
)
```


```{r saveExternally}
# save imported and formatted data to 
feather::write_feather(data,
                       "unverifiedData_unpadded.feather")

# save list of stations:


saveRDS(data %>%
          dplyr::pull(STATION_NAME_FULL) %>%
          unique %>%
          sort,
        "allStations.rds")

readr::write_csv(data %>%
                   dplyr::select(STATION_NAME_FULL) %>%
                   distinct %>%
                   arrange(STATION_NAME_FULL),
                 "allStations.csv")
```
** UPDATE WITH STATION_NAME_FULL **

```{r regionalStation}
# THIS WILL NEED UPDATING ONCE FOLKS SEND BACK ALLSTATIONS.CSV WHICH WAS BASED ON STATION_NAME_FULL.
data<-feather::read_feather("unverifiedData_unpadded.feather")

# read in file  specified in params$stations
(stations <-
   readr::read_csv(file.path("./regionalStations", params$stations)) %>%
   dplyr::select(STATION_NAME = 2) %>%
   # make character vector
   dplyr::pull(STATION_NAME)
 )

regionalData<-data %>%
  dplyr::filter(STATION_NAME %in% stations)
```

```{r regionalStationChecks}
# how many STATION_NAME_FULL in stations
regionalData %>%
  dplyr::distinct(STATION_NAME_FULL) %>%
  dplyr::arrange(STATION_NAME_FULL)

# Find min and max dates for each STATION_NAME_FULL:
 regionalData %>%
  dplyr::filter(STATION_NAME %in% stations) %>%
  dplyr::group_by(STATION_NAME_FULL,PARAMETER) %>%
   summarise(minData=min(DATE_PST,na.rm=TRUE),
             maxData=max(DATE_PST,na.rm = TRUE)
             )
```


```{r regionalDataPadded,eval=TRUE}
# fill gaps with NA:
devtools::source_url("https://raw.githubusercontent.com/DonnaHaga/dataImport/master/functions/NAfillFcn.R")
regionalDataPadded<-NAfillFcn(regionalData)

# DATA CHECKS:
# Find min and max dates for each STATION_NAME_FULL:
 regionalDataPadded %>%
  dplyr::group_by(STATION_NAME_FULL,PARAMETER,INSTRUMENT) %>%
   dplyr::tally(.)
 
 regionalDataPadded %>%
  dplyr::group_by(STATION_NAME_FULL,PARAMETER,INSTRUMENT) %>%
   summarise(minData=min(DATE_PST,na.rm=TRUE),
             maxData=max(DATE_PST,na.rm = TRUE)
             )
 # save regionalDataPadded
 saveRDS(regionalDataPadded,
         file.path("./regionalPreppedData",params$preppedData)
 )
```

